#+title: Makefile Tutorial By Example
#+author: Translated by Thanga Ayyanar

நான் இந்த வழிகாட்டியை உருவாக்கினேன், ஏனென்றால் என்னால் மேக் கோப்பு (Makefile) பற்றி சுற்றிக்கொள்ள கடினமாக இருந்ததால். அவைகளில் மறைந்திருக்கும் விதிகள் மற்றும் மறைமுகமான சின்னங்களைக் கொண்டு இருக்கிறது, மேலும் எளிமையான கேள்விக்கு எளிமையான பதில்களைக் கொடுக்கவில்லை. இதைத் தீர்க்க, நான் பல வார இறுதிகளில் அமர்ந்து மேக் கோப்பு பற்றி என்னால் முடிந்த அனைத்தையும் படித்தேன். இந்த வழிகாட்டியில் மிக முக்கியமான விஷயங்களை நான் சுருக்கி தொகுத்து உள்ளேன். ஒவ்வொரு தலைப்புக்கும் ஒரு சுருக்கமான விளக்கமும், சுயமாக இயங்கக்கூடிய ஒரு உதாரணமும் உள்ளது.

நீங்கள் பெரும்பாலும் மேக் ஐப் புரிந்து கொண்டால், மேக் கோப்பு பயனர் கையேடுவைப் (cookbook) பார்க்கவும், இதில் மேக் கோப்பு இன் ஒவ்வொரு பகுதியும் என்ன செய்கிறது என்பதைப் பற்றிய போதுமான கருத்துகளைக் கொண்ட நடுத்தர அளவிலான திட்டங்களுக்கான (project) படிம அச்சு(template) உள்ளது.

நல் வாழ்த்துக்கள், மேக் கோப்புகளின் குழப்பமான உலகத்தை உங்களால் புரிந்துகொள்ள முடியும் என்று நம்புகிறேன்!

* துவக்கம் ஆரம்பிக்கிறது

** மேக் கோப்புகள் ஏன் உள்ளன?
ஒரு பெரிய நிரலின் எந்தப் பகுதிகளை மறுநிரல்மொழிமாற்ற(recompile) வேண்டும் என்பதைத் தீர்மானிக்க மேக் கோப்புகள் பயன்படுத்தப்படுகின்றன. பெரும்பாலான சந்தர்ப்பங்களில், C அல்லது C++ கோப்புகள் நிரல்மொழிமாற்ற(compile) படுகின்றன. பிற மொழிகள் பொதுவாக மேக் போன்ற அதே சேவை செய்யும் சொந்த கருவிகளைக் கொண்டுள்ளன. மேக் நிரல்மொழிமாற்ற மட்டும் இல்லாமல் எந்த கோப்புகள் மாறிவிட்டன என்பதைப் பொறுத்து இயக்குவதற்கு உங்களுக்கு தொடர்ச்சியான வழிமுறைகள்(series of instruction) தேவைப்படும்போதும் பயன்படுத்தலாம். 

இந்த பயிற்சியில் C/C++ நிரல்மொழிமாற்ற பயன்பாட்டு விஷயத்தில் கவனம் செலுத்தும்.

மேக் மூலம் நீங்கள் உருவாக்கக்கூடிய சார்பு வரைபடம் (dependency graph) இங்கே உள்ளது. ஏதேனும் கோப்பின் சார்புகள்(dependency) மாறினால், கோப்பு மீண்டும் நிரல்மொழிமாற்றபடும்:

#+CAPTION: Sample dependency graph for make file
#+NAME:   fig:make-dependency-graph

[[./assets/dependency_graph.png]]

** மேக் மாற்றாக வேறு என்ன மென்பொருள் உள்ளன?
பிரபலமான C/C++ க்கு மாற்று உருவாக்க அமைப்புகள்(Build tools) SCons, CMake, Bazel மற்றும் Ninja ஆகும். மைக்ரோசாஃப்ட் விஷுவல் ஸ்டுடியோ(Microsoft Visual Studio) போன்ற சில குறியீடு தொகுப்பிகள்(code editors) தங்களுக்கென உள்ளமைக்கப்பட்ட கருவிகளைக் (inbuilt tools) கொண்டுள்ளனர். ஜாவாவிற்கு(Java), அன்ட் (Ant), மேவன்(Maven) மற்றும் கிரேடில்(Gradle) உள்ளன. கோ(Go), ரஸ்ட்(Rust) மற்றும் டைப்ஸ்கிரிப்ட்(Typescript) போன்ற பிற மொழிகள் அவற்றின் சொந்த உருவாக்கப்பட்ட கருவிகளைக் கொண்டுள்ளன.

பைதான்(Python), ரூபி(Ruby) மற்றும் ரா ஜாவாஸ்கிரிப்ட்(Raw Javascri;pt) போன்ற நிரற்பெயர்ப்பி மொழிகளுக்கு (Interpreted language) மேக் கோப்பு தேவையில்லை. மேக் கோப்புபின் குறிக்கோள், எந்த கோப்புகள் மாறியுள்ளன என்பதை அடிப்படையாகக் கொண்டு நிரல்மொழிமாற்ற வேண்டிய கோப்புகளை நிரல்மொழிமாற்ற வேண்டும். ஆனால் நிரற்பெயர்ப்பி மொழிகளில் உள்ள கோப்புகள் மாறும்போது, ​​எதையும் மறுநிரல்மொழிமாற்ற வேண்டியதில்லை. நிரல் இயங்கும் போது, ​​கோப்பின் சமீபத்திய பதிப்புயை பயன்படுத்தப்படும்.

** மேக்கின் பதிப்புகள் மற்றும் வகைகள்
மேக்கின் பல்வேறு செயலாக்கங்கள்(implementation) உள்ளன, ஆனால் இந்த வழிகாட்டியில் பெரும்பாலானவை நீங்கள் பயன்படுத்தும் எந்தப் பதிப்பிலும்(version) வேலை செய்யும். இருப்பினும், இது குறிப்பாக குனு மேக்காக(GNU Make) எழுதப்பட்டது, இது லினக்ஸ் மற்றும் மாக்(Mac) இல் நிலையான செயலாக்கமாகும். அனைத்து எடுத்துக்காட்டுகளும் மேக் பதிப்புகள் 3 மற்றும் 4 க்கு வேலை செய்கின்றன, அவை சில மறைபொருள்(esoteric) வேறுபாடுகளைத் தவிர கிட்டத்தட்ட சமமானவை.

** எடுத்துக்காட்டுகளை இயக்குதல்
இந்த உதாரணங்களை இயக்க, உங்களுக்கு கட்டளை வரி(Terminal/Command Line) மற்றும் "மேக்" நிறுவயிருக்க வேண்டும். ஒவ்வொரு உதாரணத்திற்கும், ~Makefile~ எனப்படும் கோப்பில் உள்ளடக்கங்களை(contents) வைத்து, அந்த கோப்பகத்தில்(folder) மேக் கட்டளையை இயக்கவும். எளிமையான மேக் கோப்பு உடன் ஆரம்பிக்கலாம்:

#+begin_src makefile
hello:
	echo "Hello, World"
#+end_src

*குறிப்பு*: மேக் கோப்பு TABகளைப் பயன்படுத்தி உள்தள்ளப்பட(indent) வேண்டும், இடைவெளிகள்(space) பயன்படுத்தினால் make தோல்வியடையும்.

மேலே உள்ள உதாரணத்தை இயக்குவதன் வெளியீடு(output) இங்கே:
#+begin_src shell
$ make
echo "Hello, World"
Hello, World
#+end_src

அவ்வளவுதான்!

** மேக் கோப்பு தொடரியல்(Syntax)
ஒரு மேக் கோப்பு விதிகளின் தொகுப்பைக்(set of rules) கொண்டுள்ளது. ஒரு விதி பொதுவாக இது போல் இருக்கும்:
#+begin_src makefile
இலக்குகள்: முன்நிபந்தனைகள்
	கட்டளை
	கட்டளை
	கட்டளை	  
#+end_src
- இலக்குகள் கோப்பு பெயர்கள், இடைவெளிகளால்(space) பிரிக்கப்படுகின்றன. பொதுவாக, ஒரு விதிக்கு ஒன்று மட்டுமே இருக்க வேண்டும்.
- கட்டளைகள் என்பது இலக்கை (களை) உருவாக்க பொதுவாகப் பயன்படுத்தப்படும் படிகளின் வரிசையாகும்(series of steps). இவை Tab எழுத்துடன் தொடங்க வேண்டும், இடைவெளிகள்(space) அல்ல.
- முன்நிபந்தனைகள் கோப்பு பெயர்கள், இடைவெளிகளால் பிரிக்கப்படுகின்றன. இலக்குக்கான கட்டளைகளை இயக்கும் முன் இந்தக் கோப்புகள் இருக்க வேண்டும். இவை சார்புகள்(dependency) என்றும் அழைக்கப்படுகின்றன.

** மேக்கின் சாராம்சம்
ஒரு உலகத்திற்கு வணக்கம்(Hello world) உதாரணத்துடன் ஆரம்பிக்கலாம்:
#+begin_src makefile
hello:
	echo "Hello, World"
	echo "This line will print if the file hello does not exist."	  
#+end_src

ஏற்கனவே இங்கே கற்றுக்கொள்ள நிறைய இருக்கிறது. அதை ஒவ்வொன்றாக பார்க்கவும்:
- நம்மிடம் ~hello~ என்று ஒரு இலக்கு உள்ளது
- இந்த இலக்கு இரண்டு கட்டளைகளைக் கொண்டுள்ளது
- இந்த இலக்குக்கு முன்நிபந்தனைகள் எதுவும் இல்லை

நாம் ~make hello~ என்று இயக்குவோம். hello கோப்பு இல்லாத வரை, கட்டளைகள் இயங்கும். hello இருந்தால், எந்த கட்டளையும் இயங்காது.

நான் hello ஒரு இலக்கு மற்றும் ஒரு கோப்பு என்று பேசுகிறேன் என்பதை உணர வேண்டியது அவசியம். இரண்டும் நேரடியாக இணைந்திருப்பதே இதற்குக் காரணம். பொதுவாக, ஒரு இலக்கு இயக்கப்படும் போது (ஒரு இலக்கின் கட்டளைகள் இயக்கப்படும் போது), கட்டளைகள் இலக்கின் அதே பெயரில் ஒரு கோப்பை உருவாக்கும். இந்த வழக்கில், hello இலக்கு hello கோப்பை உருவாக்காது.

மிகவும் பொதுவான மேக் கோப்புகலை உருவாக்குவோம் - ஒரு சி கோப்பை நிரல்மொழிமாற்றும்(compile). ஆனால் நாம் அதை செய்வதற்கு முன், பின்வரும் உள்ளடக்கங்களைக் கொண்ட blah.c என்ற கோப்பை உருவாக்கவும்:
#+NAME: blah.c
#+begin_src c
// blah.c
#include<stdio.h>
int main() { 
  return 0; 
}
#+end_src
பின்னர் Makefile எனப்படும் கோப்புயை உருவாக்கவும். அதில் பின்வரும் உள்ளடக்கங்களை எழுதவும்.
#+begin_src makefile
blah:
	cc blah.c -o blah	  
#+end_src

இந்த நேரத்தில், make ஐ இயக்க முயற்சிக்கவும். மேக் கட்டளைக்கு தருமதிப்பு(argument) என எந்த இலக்கும் வழங்கப்படவில்லை என்பதால், முதல் இலக்கு இயக்கப்படுகிறது. இந்த வழக்கில், ஒரே ஒரு இலக்கு (blah) உள்ளது. நீங்கள் இதை முதல் முறையாக இயக்கும் போது, ​​blah உருவாக்கப்படும். இரண்டாவது முறை, நீங்கள் make இயக்கும் போது ~make: 'blah' is up to date~ என்று வரும். ஏனென்றால் blah கோப்பு ஏற்கனவே இருப்பதால் தான். ஆனால் ஒரு சிக்கல் உள்ளது: நாம் blah.c ஐ மாற்றியமைத்த, பின்னர் make ஐ இயக்கினால், எதுவும்  மறுநிரல்மொழிமாற்ற(recompile) படாது.

ஒரு முன்நிபந்தனையைச் சேர்ப்பதன் மூலம் இதை நாம் தீர்க்கிறோம்:
#+begin_src makefile
blah: blah.c
	cc blah.c -o blah	  
#+end_src
மீண்டும் make ஐ இயக்கும்போது, ​​பின்வரும் படிநிலைகள் நடக்கும்:

- முதல் இலக்கு தேர்ந்தெடுக்கப்பட்டது, ஏனெனில் முதல் இலக்கு இயல்புநிலை(default) இலக்காகும்
- இதற்கு blah.c இன் முன்நிபந்தனை உள்ளது
- அது blah இலக்கை இயக்க வேண்டுமா என்பதை முடிவு செய்யும். blah இல்லாவிட்டால் அல்லது blah.c, blah விட புதியதாக இருந்தால் மட்டுமே அது இயங்கும்

இந்த கடைசி படி முக்கியமானதாகும், மேலும் இது make இன் சாராம்சமாகும். அது என்ன செய்ய முயற்சிக்கிறது என்றால் blah கடைசியாக நிரல்மொழிமாற்ற பட்டதிலிருந்து blah முன்நிபந்தனைகள் மாறியிருக்கிறதா என்று. அதாவது, blah.c மாற்றியமைக்கப்பட்டால், மேக் கோப்பை மறுநிரல்மொழிமாற்ற(recompile) வேண்டும். மற்றும் மாறாக, blah.c மாறவில்லை என்றால், அது மறுநிரல்மொழிமாற்ற(recompile) கூடாது.

இதைச் செய்ய, கோப்பமைப்பு நேர முத்திரைகளை(Timestamp) பதிலியாக(proxy) பயன்படுத்தி ஏதாவது மாற்றம் ஏற்பட்டுள்ளதா என்பதைத் தீர்மானிக்கிறது. இது ஒரு நியாயமான பட்டறிவுசார்(heuristic) ஆகும், ஏனெனில் கோப்பு நேர முத்திரைகள் பொதுவாக கோப்புகள் மாற்றப்பட்டால் மட்டுமே மாறும். ஆனால் இது எப்போதும் இப்படி இருக்காது என்பதை உணர வேண்டியது அவசியம். உதாரணமாக, நீங்கள் ஒரு கோப்பை மாற்றலாம், பின்னர் அந்தக் கோப்பின் மாற்றியமைக்கப்பட்ட நேர முத்திரையை பழையதாக மாற்றலாம். நீங்கள் அவ்வாறு செய்தால், கோப்பு மாறவில்லை என்று மேக் தவறாக யூகித்து, இயக்கத்தை புறக்கணிக்கப்படலாம்.

இதை நீங்கள் புரிந்துகொள்வதை உறுதிப்படுத்திக் கொள்ளுங்கள். இது Makefiles இன் முக்கிய அம்சமாகும், மேலும் நீங்கள் சரியாகப் புரிந்துகொள்ள சில நிமிடங்கள் ஆகலாம். மேலே உள்ள உதாரணங்களுடன் விளையாடுங்கள்.

** மேலும் விரைவான எடுத்துக்காட்டுகள்

பின்வரும் மேக் கோப்பு இறுதியில் மூன்று இலக்குகளையும் இயக்குகிறது. நீங்கள் கட்டளை வரியில்(Terminal/Command Line) make ஐ இயக்கும் போது, ​​அது தொடர்ச்சியான படிகளில் blah எனப்படும் நிரலை உருவாக்கும்:

- இலக்கு blah ஐ Make தேர்வு செய்கிறது, ஏனெனில் முதல் இலக்கு இயல்புநிலை(default) இலக்காகும்
- blah க்கு blah.o தேவைப்படுகிறது, எனவே blah.o இலக்கைத் தேடுகிறது
- blah.o க்கு blah.c தேவைப்படுகிறது, எனவே blah.c இலக்கைத் தேடுகிறது
- blah.c க்கு சார்புகள்(dependency) இல்லை, எனவே echo கட்டளை இயக்கப்படுகிறது
- cc -c கட்டளை இயக்கப்படுகிறது, ஏனெனில் blah.o சார்புகள் அனைத்தும் முடிந்துவிட்டன
- மேல் cc கட்டளை இயக்கப்படுகிறது, ஏனெனில் அனைத்து blah சார்புகளும் முடிந்துவிட்டன
- அவ்வளவுதான்: blah ஒரு நிரல்மொழிமாற்ற பட்ட c நிரல்
#+begin_src makefile
blah: blah.o
	cc blah.o -o blah # முன்றாவது ஆக இயங்கும்

blah.o: blah.c
	cc -c blah.c -o blah.o # இரண்டாவது ஆக இயங்கும்

# பொதுவாக blah.c ஏற்கனவே இருக்கும், ஆனால் தேவையான கூடுதல் கோப்புகளை நான் குறைக்க விரும்புகிறேன்
blah.c:
	echo "int main() { return 0; }" > blah.c # முதலில் இயங்கும்	  
#+end_src

நீங்கள் blah.c ஐ நீக்கினால், மூன்று இலக்குகளும் மீண்டும் இயக்கப்படும். நீங்கள் அதைத் திருத்தினால் (இதனால் நேர முத்திரையை blah.o ஐ விட புதியதாக மாறும்), முதல் இரண்டு இலக்குகள் இயங்கும். நீங்கள் touch blah.o ஐ இயக்கினால் (இதனால் நேர முத்திரையை blah ஐ விட புதியதாக மாறும்), பிறகு முதல் இலக்கு மட்டுமே இயங்கும். நீங்கள் எதையும் மாற்றவில்லை என்றால், இலக்குகள் எதுவும் இயங்காது. முயற்சி செய்து பாருங்கள்!

இந்த அடுத்த உதாரணம் புதிதாக எதையும் செய்யவில்லை, இருப்பினும் இது ஒரு நல்ல கூடுதல் எடுத்துக்காட்டு. இது எப்போதும் இரண்டு இலக்குகளையும் இயக்கும், ஏனெனில் some_file other_file சார்ந்தது, அது எப்போதும் கோப்பை உருவாக்காது.
#+begin_src makefile
some_file: other_file
	echo "This will always run, and runs second"
	touch some_file

other_file:
	echo "This will always run, and runs first"	  
#+end_src

** மேக் கிளீன் (make clean)

clean என்பது பெரும்பாலும் மற்ற இலக்குகளின் வெளியீட்டை(output) அகற்றும் இலக்காகப் பயன்படுத்தப்படுகிறது, ஆனால் இது மேக் என்பதில் ஒரு சிறப்புச் சொல் அல்ல. some_file உருவாக்க மற்றும் நீக்க, இதில் make மற்றும் make clean இயக்கலாம்.

கிளீன்(clean) இங்கே இரண்டு புதிய விஷயங்களைச் செய்கிறது என்பதை நினைவில் கொள்க:

- இது முதலில் இல்லாத ஒரு இலக்கு (இயல்புநிலை), மற்றும் இதற்கு முன்நிபந்தனை அல்ல. அதாவது make clean என்று நீங்கள் வெளிப்படையாக அழைக்கும் வரை இது இயங்காது
- இது ஒரு கோப்பு பெயராக இருக்கவில்லை. உங்களிடம் ஒரு கோப்பு clean என்று இருந்தால், இந்த இலக்கு இயங்காது, அது நாம் விரும்புவதில்லை. இதை எப்படி சரிசெய்வது என்பது குறித்த இந்த பயற்சியில் .PHONYஐப் என்று பிறகு பார்ப்போம்.

#+begin_src makefile
some_file: 
	touch some_file

clean:
	rm -f some_file	  
#+end_src

** மாறிகள்(variables)
மாறிகள் சரங்களாக(string) மட்டுமே இருக்க முடியும். நீங்கள் பொதுவாக := ஐப் பயன்படுத்துவோம், ஆனால் = ஏன் வேலை செய்கிறது. மாறிகள் பாகம் 2 ஐப் பார்க்கவும்.

மாறிகளைப் பயன்படுத்துவதற்கான எடுத்துக்காட்டு இங்கே:
#+begin_src makefile
files := file1 file2
some_file: $(files)
	echo "Look at this variable: " $(files)
	touch some_file

file1:
	touch file1
file2:
	touch file2

clean:
	rm -f file1 file2 some_file	  
#+end_src
ஒற்றை அல்லது இரட்டை மேற்கோள்களுக்கு(quotes) அர்த்தம் இல்லை மேக்கில். அவை வெறுமனே மாறிக்கு ஒதுக்கப்பட்ட எழுத்துக்கள். மேற்கோள்கள் ஷெல்(shell)/பாஷுக்கு(Bash) பயனுள்ளதாக இருக்கும், மேலும் அவை உங்களுக்கு printf போன்ற கட்டளைகளில் தேவைப்படும். இந்த எடுத்துக்காட்டில், இரண்டு கட்டளைகளும் ஒரே மாதிரியாக செயல்படுகின்றன:
#+begin_src makefile
a := one two # a ஆனது "one two" என்ற சரத்திற்கு அமைக்கப்பட்டுள்ளது
b := 'one two' # பரிந்துரைக்கப்படவில்லை. b ஆனது "'one two'" சரத்திற்கு அமைக்கப்பட்டுள்ளது
all:
	printf '$a'
	printf $b
#+end_src
மாறிகளைப் பயன்படுத்த ${} அல்லது $()
#+begin_src makefile
x := dude

all:
	echo $(x)
	echo ${x}

	echo $x # தவறான நடைமுறை, ஆனால் வேலை செய்கிறது
#+end_src

* இலக்குகள் (Targets)
** all இலக்கு
பல இலக்குகளை உருவாக்கி, அவை அனைத்தும் இயங்க வேண்டுமா? all இலக்கை உருவாக்குங்கள். இது பட்டியலிடப்பட்ட முதல் விதி என்பதால், இலக்கைக் குறிப்பிடாமல் make என்று அழைக்கப்பட்டால் அது இயல்பாகவே இயங்கும்.
#+begin_src makefile
all: one two three

one:
	touch one
two:
	touch two
three:
	touch three

clean:
	rm -f one two three
#+end_src

** பல இலக்குகள் (Multiple targets)
ஒரு விதிக்கு பல இலக்குகள் இருக்கும்போது, ​​ஒவ்வொரு இலக்கிற்கும் கட்டளைகள் இயக்கப்படும். $@ என்பது இலக்கு பெயரைக் கொண்ட ஒரு தானியங்கி மாறி(automatic variable).
#+begin_src makefile
all: f1.o f2.o

f1.o f2.o:
	echo $@
# இதற்கு சமம்:
# f1.o:
#	 echo f1.o
# f2.o:
#	 echo f2.o
#+end_src
